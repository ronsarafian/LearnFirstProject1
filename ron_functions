
import os
import numpy as np
import cv2
import pickle
import matplotlib.pyplot as plt
from itertools import product
import pandas as pd
from sklearn.svm import LinearSVC
import sklearn.metrics as skm
from skimage.feature import hog
from sklearn import svm
import gc

data_path = os.path.join(os.getcwd(), "101_ObjectCategories")
class_indices = np.arange(10, 20)





def get_default_params():

    default_params = {
        "data_path": data_path,
        "images_per_class_train": 20,
        "images_per_class_validation": 20,
        "image_size": (100, 100),
        "load_data": True,
        "test_class": class_indices,
        "pixels_per_cell": (5, 5),
        "cells_per_block": (4, 4),
        "C": 1,
        "svm_type": "poly2"}
    return default_params




def get_data (params):

    name = []
    data = []
    label = []

    for n, dir in enumerate(os.listdir(params["data_path"])):
        name.append(dir)
        images = os.listdir(os.path.join(params["data_path"], dir))
        n_images = min(params["images_per_class_train"] + params["images_per_class_validation"], len(images))
        for file in images[0:n_images]:
            label.append(n)
            image = cv2.imread(os.path.join(params["data_path"], dir, file), cv2.IMREAD_GRAYSCALE)
            image = cv2.resize(image.astype(np.float), params["image_size"])
            data.append(image)

    data = np.stack(data, axis=0)
    label = np.array(label, dtype=np.int)

    return name, label, data




def split_data (data, label, params):

    fold1_x, fold1_y = data[np.isin(label, np.arange(10))], label[np.isin(label, np.arange(10))]
    fold2_x, fold2_y = data[np.isin(label, params["test_class"])], label[np.isin(label, params["test_class"])]

    return fold1_x, fold1_y, fold2_x, fold2_y



def validation_split(X, y, params):
    x_tr = []
    y_tr = []
    x_ts = []
    y_ts = []

    for i in np.unique(y):
        x_tr.append(X[y == i][0:params["images_per_class_train"]])
        y_tr.append(y[y == i][0:params["images_per_class_train"]])
        x_ts.append(X[y == i][params["images_per_class_validation"]:])
        y_ts.append(y[y == i][params["images_per_class_validation"]:])

    x_tr, y_tr, x_ts, y_ts = np.vstack(x_tr), np.concatenate(y_tr), np.vstack(x_ts), np.concatenate(y_ts)

    return x_tr, y_tr, x_ts, y_ts



def hog_rep (data, params):

    # HOG representation
    X = []
    for i in np.arange(0, data.shape[0]):
        hog_rep = hog(image=data[i], orientations=9, pixels_per_cell=params["pixels_per_cell"],
                      cells_per_block=params["cells_per_block"], block_norm='L2')
        X.append(hog_rep)

    X = np.stack(X, axis=0)
    return X



def train (x_tr, y_tr, params):

    if params["svm_type"] == "linear":
        clf = LinearSVC(random_state=0, tol=1e-4, C=params["C"], multi_class="ovr")
        clf.fit(x_tr, y_tr)
    else:
        if params["svm_type"].endswith("2"):
            poly_degree = 2
        else:
            poly_degree = 3

        clf = []
        for i in np.unique(y_tr):
            y_tr_binar = []
            for j in range(len(y_tr)):
                if y_tr[j] == i:
                    y_tr_binar.append(1)
                else:
                    y_tr_binar.append(-1)
                clf_binar = svm.SVC(C=params["C"], kernel='poly', degree=poly_degree)
            clf_binar.fit(x_tr, y_tr_binar)
            clf.append(clf_binar)

    return clf




def test(model, x_ts, y_ts, params):
    if params["svm_type"] == "linear":
        score = model.score(x_ts, y_ts)
        pred = model.predict(x_ts)

    else:
        decisions = []
        for binar_clf in model:
            decision = binar_clf.decision_function(x_ts)
            decisions.append(decision)
        decisions = pd.DataFrame(decisions).T
        pred = np.unique(y_ts)[decisions.idxmax(axis=1)]
        score = skm.accuracy_score(y_ts, pred)

    return score, pred


def expandgrid(dictionary):
   return pd.DataFrame([row for row in product(*dictionary.values())],
                       columns=dictionary.keys())

# X = np.array([[1,1.2,1.3,1.4,1.5,2,2.1,2.2,2.3,2.4,2.5,3,3.1,3.2,3.3,3.4,3.5],
#      [1,1.22,1.13,1.14,1.45,2,2.41,2.62,2.37,2.24,2.35,3,3.15,3.32,3.36,3.24,3.15]]).transpose()
# y = np.array([1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3])

def learn(x_tr, y_tr, x_ts, y_ts, tunegrid):
    clfs = []
    scores = []

    for i in np.arange(0,tunegrid.shape[0]):

        params = {}
        params["svm_type"] = tunegrid.svm_type[i]
        params["pixels_per_cell"] = tunegrid.pixels_per_cell[i]
        params["cells_per_block"] = tunegrid.cells_per_block[i]
        params["svm_type"] = tunegrid.svm_type[i]
        params["C"] = tunegrid.C[i]

        x_tr_hog, x_ts_hog = hog_rep(x_tr, params), hog_rep(x_ts, params)
        clf = train(x_tr_hog, y_tr, params)
        score, pred = test(clf, x_ts_hog, y_ts, params)

        clfs.append(clf)
        scores.append(score)

        gc.collect()

    np.asarray(scores)
    best_clf = clfs[np.argmax(scores)]
    tuned_hyperparameters = tunegrid.iloc[np.argmax(scores)]

    return best_clf, scores, tuned_hyperparameters



def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, format(cm[i, j], fmt),
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.tight_layout()

